schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Query {
  me: User
  games: [Game]
  users: [User]
}

type Mutation {
  login(id: ID): LoginResult!
  joinGame: JoinGameResult!
  playMove(input: PlayMoveInput!): PlayMoveResult!
}

type Subscription {
  gameChanged(gameId: ID!): Game!
  # I want these two for debugging only
  gameAdded: Game!
  userCreated: User!
}

type User {
  id: ID!
}

type LoginResult {
  user: User!
  created: Boolean!
}

type JoinGameResult {
  gameId: ID!
  token: Token!
}

input PlayMoveInput {
  gameId: ID!
  token: Token!
  position: Position!
}

union PlayMoveResult =
    MoveResult
  | ErrorGameOver
  | ErrorWrongMove
  | ErrorWrongTurn
  | ErrorInvalidMove

type MoveResult {
  id: ID!
}

type ErrorGameOver {
  message: String!
}

type ErrorInvalidMove {
  message: String!
}

type ErrorNotFound {
  message: String!
}

type ErrorWrongMove {
  message: String!
}

type ErrorWrongTurn {
  message: String!
}

union Game = GamePlaying | GameOverWin | GameOverTie

type GamePlaying {
  id: ID!
  moves: [Move!]!
  next: Token!
}

type GameOverWin {
  id: ID!
  moves: [Move!]!
  winner: Token!
  winningMove: Win!
}

type GameOverTie {
  id: ID!
  moves: [Move!]!
}

type Move {
  position: Position!
  token: Token!
}

# this can be inferred from the parent
# remove from the api and use ttt-core
# to extract from the game
type Win {
  p1: Position!
  p2: Position!
  p3: Position!
}

"""
The Os and Xs in tic-tac-toe
"""
enum Token {
  O
  X
}

"""
Represents a tic-tac-toe board, like this:
A B C
D E F
G H I
"""
enum Position {
  A
  B
  C
  D
  E
  F
  G
  H
  I
}
